<!DOCTYPE html>
<html>
<head>	
    <title>v.1.7</title>
    <meta charset="utf-8" />
    <style>
        table {
            border: 1px solid black;
            font-family: arial, sans-serif;
            width: 100%;
        }

        td, th {
            border: 1px solid black;
            text-align: left;
            padding: 3px;
        }

        tr:nth-child(even) {
            background-color: grey;
        }

        .questiion {
            font-family: "PT Sans", Arial;
            font-size: 17px;
            font-weight: bold;
        }

        .theme {
            font-family: "PT Sans", Arial;
            font-size: 20px;
        }

        .link {
            font-size: 18px;
            font-weight: bold;
        }
		
		<!-- .header { -->
			<!-- background-color: #000; -->
			<!-- color: #fff; -->
			<!-- clear: both; -->
			<!-- width: 90%; -->
			<!-- position: fixed; -->
			<!-- top: 0px; -->
			<!-- display: none; -->
		<!-- } -->
		
		a.footerLink:visited {
			 color: Black;
			 width: 100%;
		}
		.footer {
			background-color: #527a7a;
			color: Black;
			width: 100%;
			clear: both;
			position: fixed; 
			bottom: 0px;
		}
		
		/* unvisited link */
		a:link {
			color: blue;
		}

		/* visited link */
		a:visited {
			color: black;
		}

		/* mouse over link */
		a:hover {
			color: black;
		}

		/* selected link */
		a:active {
			color: black;
		}
    </style>
</head>
<body>
	<div id="top"><b>CheetSheet</b>
	</div>
    <a href="#dotnetquestion">Общие вопросы по C#, .NET</a><br />
    <a href="#sqlquestion">Вопросы по MS SQL</a><br />
    <a href="#patternsquestion">Вопросы по шаблонам проектирования</a><br />
    <a href="#testingquestion">Вопросы по Unit Tests</a><br />
    <a href="#mvcquestion">Вопросы по ASP.NET MVC</a><br />
    <a href="#solidquestion">Вопросы по SOLID</a><br />
    <a href="#aaaa"></a>    <br />
    <div class="theme" id="dotnetquestion">Общие вопросы по C#, .NET</div>
    <div>
        <a href="#wcf">WCF</a><br />
        <a href="#oop">
            Назвать три основных свойства ООП. Рассказать про каждый из них.
            Как каждое из них реализуется на уровне C#.
        </a><br />
        <a href="#mainmethodsobject">Основные методы класса Object</a><br />
        <a href="#inherit">Как можно реализовать наследование?</a><br />
        <a href="#dotnet">Что такое .NET ?</a><br />
        <a href="#dll">Из чего состоит .exe или .dll файлы?</a><br />
        <a href="#serialization">Что такое сериализация и для чего она нужна?</a><br />
        <a href="#privatememberserialization">Можно ли сериализовать private член</a><br />
        <a href="#reflection">Что такое рефлексия? Как получить список свойств у объекта?</a><br />
        <a href="#readonlyvsconst">Различие между read only & const</a><br />
        <a href="#concat">Каким образом лучше всего объединить несколько строк в одну строку?</a><br />
        <a href="#lambda">Что такое лямбда выражение?</a><br />
        <a href="#asyncawiat">Что такое async await?</a><br />
        <a href="#eventvsdelegate">Чем делегаты отлечаются от событий?</a><br />
        <a href="#staticvsnonstatic">
            Чем статические классы отличаются от нестатических? 
            Когда происходит вызов конструктора статического класса?
        </a><br />
        <a href="#paramsmethod">В чем преимущество параметризированных классов и методов?</a><br />
        <a href="#extencion">Что такое Extension методы (навески)? Для чего используются?</a><br />
        <a href="#enum">Что такое перечисления (enum)?</a><br />
        <a href="#refvsvalue">Что такое ссылочные и значимые типы? В чем разница?</a><br />
        <a href="#gc">Для чего нужен сборщик мусора и как он работает?</a><br />
        <a href="#idisposable">Какую роль играет интерфейс IDisposable?</a><br />
        <a href="#synchronizethread">Как синхронизировать запрос к свойству класса из двух потоков?</a><br />
        <a href="#interfacevsabstract">В чем разница между абстрактным классом и интерфейсом?</a><br />
        <a href="#explicitvsimplicit">Чем отличается явное приведение типов от неявного?</a><br />
        <a href="#variativnost">
            List наследуется от двух интерфейсов - IList и IEnumerable.
            Почему List&lt;string&gt;можно привести к IEnumerable&lt;object&gt;, а к IList&lt;object&gt; нельзя?
        </a><br />
        <a href="#variacia">С чем можно использовать вариацию?</a><br />
        <a href="#genericconstraint">Расскажите про ограничения обобщенных типов</a><br />
        <a href="#overridegenericы">Как происходит перегрузка обощенных классов и методов?</a><br />
        <a href="#explicitinterface">
			Для чего используется объявление метода в классе явно вместе с сигнатурой интерфейса?
		</a><br />
        <a href="#nondispose">Приведите пример, как можно “засорить” память приложения?</a><br />
        <a href="#jit">Что такое JIT компилятор? Для чего он нужен?</a><br />
        <a href="#metadata">Что такое метаданные и что такое манифест?</a><br />
        <a href="#bixingunboxing">Что такое boxing and unboxing? Когда она происходит?</a><br />
        <a href="#changeprivatevar">* Как можно изменить private поле у объекта во время runtime в обход компилятора?</a><br />
        <a href="#internirovanie">Что такое Интернирование строк?</a><br />
        <a href="#concurentcollection">Потокобезопастные коллекции</a><br />
        <a href="#accessmodifiers">Модификаторы доступа</a><br />
        <a href="#taskvsthread">Различие между Task и Thread</a><br />
        <a href="#aaaa"></a><br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="wcf">WCF</div>
            <div>
				<b>Windows Communication Foundation (WCF)</b> — программный фреймворк, используемый для обмена данными между
				компонентами распределенного приложения в сети.<br />
                <b>Windows Communication Foundation (WCF)</b> — программный фреймворк, используемый для обмена данными между
                приложениями, входящий в состав .NET Framework. До своего выпуска в декабре 2006 года в составе
                .NET Framework 3.0, WCF был известен под кодовым именем Indigo. WCF делает возможным построение
                безопасных и надёжных транзакционных систем через упрощённую унифицированную программную модель
                межплатформенного взаимодействия. Комбинируя функциональность существующих технологий .NET по разработке
                распределённых приложений (ASP.NET XML Web Services — ASMX, WSE 3.0, .NET Remoting,
                .NET Enterprise Services и System.Messaging), WCF предоставляет единую инфраструктуру разработки, при
                умелом применении повышающую производительность и снижающую затраты на создание безопасных, надёжных и
                транзакционных Web-служб нового поколения. Заложенные в неё принципы интероперабельности позволяют
                организовать работу с другими платформами, для чего используются технологии взаимодействия платформ,
                например WSIT, разрабатываемые на базе открытого исходного кода.
            </div>
        </li>
        <li>
            <div class="questiion" id="oop">
                Назвать три основных свойства ООП. Рассказать про каждый из них.
                Как каждое из них реализуется на уровне C#.
            </div>
            <div>
				<b>Наследование</b> - процесс в результате кт. один объект получает все свойства другого<br/>
				<b>Полиморфизм</b> - свойство, кт. позволяет использовать одно и тоже имя для решения двух и более одинаковых, 
				но технически разных задач<br/>
				<b>Инкапсуляция</b> - механизм, кт. объединяет данные и код, манипулирует ими и защищает их от внешнего 
				вмешательства или неправильного использования<br/>
				<b>Абстра́кция</b> — это придание объекту характеристик, которые чётко определяют его концептуальные границы, отличая от всех других объектов.
            </div>
        </li>
        <li>
            <div class="questiion" id="">
                Различие между объектом и классом
            </div>
            <div>
				<b>Объект</b> - экземпляр класса<br/>
				<b>Класс</b> - определение объекта<br/>
				An object is an instance of a class. <br/>
				A class is the definition of an object. It does not actually become an object until it is instantiated. Since an abstract class can't be instantiated, no object of that type can created. A sub class would need to be defined in order for an object to created.
            </div>
        </li>
        <li>
            <div class="questiion" id="mainmethodsobject">Основные методы класса Object</div>
            <div>
			Public methods:
				<b>Equlas</b><br/>
				<b>GetHashCode</b><br/>
				<b>GetType</b><br/>
				<b>GetToString</b><br/>
			Protected methods:
				<b>Finalize</b>
				<b>MemberwiseClone</b>
            </div>
        </li>
        <li>
            <div class="questiion" id="inherit">
                Как можно реализовать наследование?
            </div>
            <div>
				<div class="link"> http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html </div>
				<b>Наследование</b> - это такой вид связи (отношение «является», IS A Relationship), которое говорит, что все, 
				что справедливо для базового класса справедливо и для его наследника. <br/>
				<b>Композиция</b> - это такой вид связи (HAS-A Relationship), в кт. целое явно контролирует время жизни своей 
				составной части (часть не существует без целого).<br/>
				class CompositeCustomService <br/>
				{ <br/>
					// Композиция <br/>
					private readonly CustomRepository _repository <br/>
						  = new CustomRepository(); <br/>
					public void DoSomething() <br/>
					{ <br/>
						// Используем _repository <br/>
					}<br/>
				} <br/>
				<b>Агрегация</b> - это такой вид связи (HAS-A Relationship), в кт. целое хоть и содержит свою составную часть, 
				время их жизни не связано <br/>
				class AggregatedCustomService <br/>
				{ <br/>
					// Агрегация<br/>
					private readonly AbstractRepository _repository; <br/>
					public AggregatedCustomService(AbstractRepository repository) <br/>
					{ <br/>
						_repository = repository; <br/>
					} <br/>
					public void DoSomething() <br/>
					{ <br/>
						// Используем _repository <br/>
					} <br/>
				} <br/>				
            </div>
        </li>
        <li>
            <div class="questiion" id="dotnet">Что такое .NET ?</div>
            <div>
                <b>CLR</b> - Common Language Runtime<br/>
				<b>FCL</b> - Framework Class Library
            </div>
        </li>
        <li>
            <div class="questiion" id="dll">Из чего состоит .exe или .dll файлы?</div>
            <div>
                Управляемый PE-файл состоит из 4-х частей:<br />
                заголовка PE32(+), заголовка CLR, метаданных и кода на промежуточном языке (intermediate language, IL)<br />
				<table>
                    <tr>
                        <th>Часть</th>
                        <th>Описание</th>
                    </tr>
                    <tr>
                        <td>Заголовок PE32 или PE32+</td>
                        <td>Стандартный заголовок PE-файла Windows, аналогичный заголовку Common Object File Format (COFF). Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64-разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран. Для модулей, содержащих только IL-код, основной объем информации в заголовке PE32(+) игнорируется. В модулях, содержащих машинный код, этот заголовок содержит сведения о машинном коде
						</td>
                    </tr>
                    <tr>
                        <td>Заголовок CLR</td>
                        <td>Содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль в управляемый. Заголовок включает нужную версию CLR, некоторые флаги, метку метаданных MethodDef точки входа в управляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр.
						</td>
                    </tr>
                    <tr>
                        <td>Метаданные</td>
                        <td>Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены, определенные в исходном коде, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки в исходном коде
						</td>
                    </tr>
                    <tr>
                        <td>Код Intermediate Language (IL)</td>
                        <td>Код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды
						</td>
                    </tr>
                </table>
                Рихтер - несколько слов о метаданных<br/>
				Таблица 1.1 Части управляемого модуля
            </div>
        </li>
        <li>
            <div class="questiion" id="serialization">
                Что такое сериализация и для чего она нужна? 
				Какие есть сериализаторы?<br />
            </div>
            <div>
                Сериализация представляет процесс преобразования какого-либо объекта в поток байтов. После преобразования
                мы можем этот поток байтов или записать на диск или сохранить его временно в памяти. А при необходимости
                можно выполнить обратный процесс - десериализацию, то есть получить из потока байтов ранее сохраненный
                объект.<br />
				<b>BinaryFormatter</b><br />
				<b>DataContractJsonSerializer</b><br />
				<b>SoapFormatter</b><br />
				<b>XmlSerializer</b><br />
            </div>
        </li>
        <li>
            <div class="questiion" id="privatememberserialization">Можно ли сериализовать private член<br />
            </div>
            <div>
                <b>BinaryFormatter</b> - да, модификатор доступа для сериализуемого класса не важен, атрибут <b>[Serializable]</b> говорит, что объекты этого класса можно сериализовать<br />
				<b>DataContractJsonSerializer</b> - да, сериализует все что имеет атрибут <b>[DataMember]</b>, модификатор доступа для сериализуемого класса не важен, атрибут <b>[DataContract]</b> говорит, что объекты этого класса можно сериализовать<br />
				<b>SoapFormatter</b> - да, модификатор доступа для сериализуемого класса не важен, атрибут <b>[Serializable]</b> говорит, что объекты этого класса можно сериализовать<br />
				<b>XmlSerializer</b> - нет, модификатор доступа для сериализуемого класса необходим <b>public</b>, атрибут <b>[Serializable]</b> говорит, что объекты этого класса можно сериализовать<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="reflection">
				Что такое рефлексия?<br/>
                Как получить список свойств у объекта?<br />
            </div>
            <div>
                <b>Рефлексия</b> представляет собой процесс выявления типов во время выполнения приложения.<br />
				Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих 
				кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные 
				элементы приложения.<br />
                Метод <b>FindMembers()</b> возвращает массив объектов <b>MemberInfo</b> данного типа<br />
                Метод <b>GetMembers()</b> возвращает все члены типа в виде массива объектов <b>MemberInfo</b><br />
                Метод GetConstructors() возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo<br />
                Метод GetEvents() возвращает все события данного типа в виде массива объектов EventInfo<br />
                Метод GetFields() возвращает все поля данного типа в виде массива объектов FieldInfo<br />
                Метод GetInterfaces() получает все реализуемые данным типом интерфейсы в виде массива объектов Type<br />
                Метод GetMethods() получает все методы типа в виде массива объектов MethodInfo<br />
                Метод GetProperties() получает все свойства в виде массива объектов PropertyInfo<br />
                Свойство IsAbstract возвращает true, если тип является абстрактным<br />
                Свойство IsArray возвращает true, если тип является массивом<br />
                Свойство IsClass возвращает true, если тип представляет класс<br />
                Свойство IsEnum возвращает true, если тип является перечислением<br />
                Свойство IsInterface возвращает true, если тип представляет интерфейс<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="lambda">
                Что такое лямбда выражение?<br />
            </div>
            <div>
                <b>Лямбда-выражения</b> представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют
                создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать 
                в качестве параметров в другие методы.<br/>
                Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список 
                параметров, а справа блок выражений, использующий эти параметры: (список_параметров) => выражение.<br/>
                Для написания можно использовать Action, Action&lt;in T&gt;, Func&lt;in TIn, out TOut&gt;, bool Predicate&lt;
				in T&gt;<br/>
				<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="readonlyvsconst">
                Различие между read only & const<br />
            </div>
				http://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly
            <div>
            </div>
        </li>
        <li>
            <div class="questiion" id="concat">
                Каким образом лучше всего объединить несколько строк в одну строку?<br />
            </div>
            <div>
                Оператором + или string.Concat() или StringBuilder
				https://coders-corner.net/2014/08/20/concatenate-strings-in-c-operator-vs-string-concat-vs-stringbuilder/
            </div>
        </li>
        <li>
            <div class="questiion" id="asyncawiat">
                Что такое async await?<br />
            </div>
            <div>
                Ключевое слово <b>async</b> указывает, что метод или лямбда-выражение являются асинхронными. Метод, помеченный
                как async должен возвращать <b>void</b>, <b>Task</b> или <b>Task&lt;T&gt;</b>, не может принимать в качестве 
				своих аргументов параметры с модификаторами ref или out, но, при этом, он может вызывать методы, имеющие такие 
				параметры.<br />
                Оператор <b>await</b> применяется к задаче в асинхронных методах, чтобы приостановить выполнение метода до
                тех пор, пока ожидаемая задача не завершится. При этом выполнение потока, в котором был вызван 
                асинхронный метод, не прерывается. Метод, помеченный как <b>await</b> должен возвращать <b>Task</b> или 
				<b>Task&lt;T&gt;</b>, может принимать в качестве своих аргументов параметры с модификаторами ref или out.<br />
				Use the <b>async</b> modifier to specify that a method, lambda expression, or anonymous method is asynchronous.
				<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="eventvsdelegate">
                Чем делегаты отлечаются от событий?<br />
            </div>
            <div>
                <div class="link"> https://msdn.microsoft.com/ru-ru/library/edzehd2t(v=vs.110).aspx </div>
				<b>Событие (Event)</b>
                (mdsn) Событие представляет собой сообщение, посылаемое объектом, чтобы сигнализировать о совершении
                какого-либо действия.<br />
				<b>Event</b> - это что-то типа property, но вместо getter'a и setter'a, у него Add и Remove. В качестве 
				значения эти Add и Remove принимают метод у кт. вигнатура совпадает с сигнатурой делегата.
				<b>Делегат (Delegate)</b>
				abstract class Delegate наследник abstract class MulticastDelegate<br />
                (Richter) Тип, в котором определено событие (или экземпляры этого типа), может уведомлять другие объекты
                о некоторых особых ситуациях, которые могут случиться.<br />
                (mdsn) Делегат — это тип, содержащий ссылку на метод. Содержит конструктор и методы:<br />
				T Invoke(), IAsyncResult BeginInvoke(), void EndInvoke(IAsyncResult)<br />
				Также тип Delegate содержит пару важных статических методов:<br />
				Delegate Delegate.Combine(Delegate d1, Delegate d2)<br />
				Delegate Delegate.Remove(Delegate d1, Delegate d2)  
            </div>
        </li>
        <li>
            <div class="questiion" id="staticvsnonstatic">
                Чем статические классы отличаются от нестатических? Когда происходит вызов конструктора статического
                класса?
            </div>
            <div>
				Если посмотреть на IL код, то мы увидим, что static это комбинация abstract и sealed. отсюда вытекает ...<br/>
				Вызов конструктора статического класса происходит при первом обращении к этому Типу.<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="paramsmethod">
                В чем преимущество параметризированных классов и методов?<br />
            </div>
            <div>
				Они могут работать с любыми типами. Проще говоря мы используем один и тот же алгоритм для разных типов.
				Производительность у таких классов лучше, т.к. у них меньше абстрактных и виртуальных методов.<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="extencion">
                Что такое Extension методы (навески)? Для чего используются?<br />
            </div>
            <div>
				<b>Методы расширения (extension methods)</b> позволяют добавлять новые методы в уже существующие типы без 
				создания нового производного класса. Эта функциональность бывает особенно полезна, когда нам хочется добавить 
				в некоторый тип новый метод, но сам тип (класс или структура) мы изменить не можем.
            </div>
        </li>
        <li>
            <div class="questiion" id="enum">
                Что такое перечисления (enum)?<br />
            </div>
            <div>
                Набор именованных констант. Все enum'ы являются производными от System.ValueType.
            </div>
        </li>
        <li>
            <div class="questiion" id="refvsvalue">
                Что такое ссылочные и значимые типы? В чем разница?<br />
            </div>
            <div>
				CLR поддерживает две разновидности типов:<br /> 
				<b>Ссылочные типы (reference types)</b> и <b>Значимые типы (value types)</b><br />

				<b>Ссылочные типы (reference types)</b><br />
				<b>class</b>, <b>interface</b>, <b>delegate</b> <br /> 
				A <b>reference type</b> нах-ся в <b>heap</b> и наследуются от <b>System.Object</b>. <br />
				Имеют два дополнительных члена: <b>type object pointer</b> and <b>syncblick index</b>. <br />
				Могут быть базовыми типами для других ссылочных типов. <br />
				Переменная ссылочного типа содержит адрес объекта в <b>heap</b>. <br />
				При присваивании одной переменной ссылочного типа другой, копируется только адрес. <br />
				Когда переменная ссылочного типа создается, она инициализируется null. Попытка использовать такую переменную чревата получением <b>NullReferenceException</b>. <br />
				Память выделяемая для ссылочных типов особождается <b>Garbage Collector</b>. <br />
				Ссылочные типы всегда нах-ся в форме boxing.<br />

				<b>Значимые типы (value types)</b><br />
				<b>struct</b>, <b>enum</b> <br />
				<b>Value type</b> располагаются в стеке потока и являются наследниками от abstract <b>System.ValueType</b>.<br />
				<b>System.ValueType</b> является наследником от <b>System.Object</b>. 
				<b>System.ValueType</b> переопределяет два метода <b>Equals</b> и <b>GetHashCode</b>.<br/>

				По умолчанию, все <b>ValueType</b> имеют модификатор <b>sealed</b>. Это означает, что любой <b>ValueType</b> не может быть базовым типом для нового типа. Так же любой <b>ValueType</b> не может иметь <b>abstract</b> или <b>virtual</b> методов.<br />

				Переменные <b>ValueType</b> содержат реальные данные. <br />					

				При присваивании одной переменной значимого типа другой, копируется весь объект. Память выделяемая им освобождается как только метод объявлявший переменную значимого типа, больше не активный. <br />
				Объекты значимых типов имеют два состояния: <b>unboxed</b> и <b>boxed</b>
            </div>
        </li>
        <li>
            <div class="questiion" id="gc">
                Для чего нужен сборщик мусора и как он работает?<br />
            </div>
            <div>
                CLR использует алгоритм отслеживания ссылок. Все переменные ссылочных типов называются корнями (roots).<br />
                Когда среда CLR запускает уборку мусора, она сначала приостанавливает все программные потоки в процессе,
                а затем определяет поколения, в которых нужно выполнить уборку мусора.<br />
                Затем CLR переходит к этапу уборки мусора, называемому маркировкой (marking). CLR перебирает все объекты в
                куче, задавая биту в поле индекса блока синхронизации значение 0. Это означает, что все эти объекты могут
                быть удалены. Затем CLR проверяет все активные корни и объекты, на которые они ссылаются. Если корень
                содержит null, CLR игнорирует его и переходит к следующему корню. Если корень ссылается на объект, в поле
                индекса блока синхронизации устанавливается бит — это и есть признак маркировки объекта. После маркировки
                объекта CLR проверяет все корни в этом объекте и маркирует объекты, на которые они ссылаются. Встретив уже
                маркированный объект, уборщик мусора останавливается, чтобы избежать возникновения бесконечного цикл
                сылок.<br />
                После проверки всех корней куча содержит набор маркированных и немаркированных объектов. Маркированные
                объекты переживут уборку мусора, потому что на них ссылается хотя бы один объект; можно сказать, что они
                достижимы из кода приложения. Немаркированные объекты недостижимы, потому что в приложении не существует
                корня, через который приложение могло бы к ним обратиться.<br />
                Теперь, когда CLR знает, какие объекты должны остаться, а какие можно удалить, начинается следующая фаза
                уборки мусора, называемая сжатием (compacting phase). В этой фазе CLR перемещает вниз все «немусорные»
                объекты, чтобы они занимали смежный блок памяти. После перемещения в памяти все ссылки на «выжившие»
                объекты обновляются, это означает, что CLR вычитает из каждого корня количество байт, на которое объект
                был сдвинут в памяти. Тем самым гарантируется, что каждый корень будет ссылаться на тот же объект, что и
                прежде. После сжатия памяти кучи в указатель NextObjPtr управляемой кучи заносится первый адрес за
                последним объектом, не являющимся мусором.<br />
                Если CLR не удается освободить память в результате уборки мусора, а в процессах не осталось адресного
                пространства для выделения нового сегмента, значит, свободная память процесса полностью исчерпана. В этом
                случае попытка выделения новой памяти оператором new приведен к выдаче исключения OutOfMemoryException.<br />
                Для работы с объектами, имеющими метод Finalize, CLR использует следующий механизм. При создании объекта,
                если он содержит метод Finalize, ссылка на него помещается в специальный список, называемый Finalization
                Queue.<br />
                После того, как GC определяет, что какой-либо объект можно удалить, ссылка на этот объект ищется в
                Finalization Queue, и если находится, то объект оставляется в покое до следующей сборки мусора, а ссылка
                на него из Finalization Queue удаляется и добавляется в другой список, называемый F-reachable Queue.<br />
                Далее этим списком занимается специально созданный для этого поток, который по очереди вызывает методы
                Finalize для объектов из F-reachable Queue, а затем удаляет их и из этого списка.
            </div>
        </li>
        <li>
            <div class="questiion" id="idisposable">Какую роль играет интерфейс IDisposable?</div>
            <div>
                Для очистки ресурсов после их использования.<br />
                using(StreamReader sr = new StreamReader(filename)){
                <br />&nbsp;&nbsp;xt = sr.ReadToEnd();<br />
                }<br />
                StreamReader sr = null;<br />
                try {
                <br />&nbsp;&nbsp;sr = new StreamReader(filename);
                <br />&nbsp;&nbsp;txt = sr.ReadToEnd();<br />
                }<br />
                finally {
                <br />&nbsp;&nbsp;if (sr != null) sr.Dispose();<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="synchronizethread">
                Как синхронизировать запрос к свойству класса из двух потоков?<br />
            </div>
            <div>
                Есть 2 вида синхронизации потоков:<br />
                <b>пользовательский режим</b><br />
                Volatile. Volatile.Read И Volatile.Write<br />
                Interlocked. Много всяких методов<br />
                <b>режим ядра</b><br />
                - Monitor (Статический класс)<br />
                - EventWaitHandle<br />
                - Mutex<br />
                - Semaphor<br />
                - AutoResetEvent – типа турникет<br />
                - ManualResetEvent – типа шлагбаум<br />
                - lock – аналог следующего кода<br />
                Boolean lockTaken = false;<br />
                try {<br />
                &nbsp;&nbsp;Monitor.Enter(this, ref lockTaken);<br />
                &nbsp;&nbsp;// Этот код имеет монопольный доступ к данным...<br />
                }<br />
                finally {<br />
                &nbsp;&nbsp;if (lockTaken) Monitor.Exit(this);<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="interfacevsabstract">
                В чем разница между абстрактным классом и интерфейсом?<br />
            </div>
            <div>
                0. АК – наследуется; И – реализуется.<br />
                1. Модификаторы доступа<br />
                2. И – нельзя объявлять поля<br />
                3. И – нельзя объявлять конструктор<br />
                4. И – нельзя объявлять статические члены<br />
                5. И – нельзя реализовать тело метода<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="explicitvsimplicit">
                Чем отличается явное приведение типов от неявного?<br />
            </div>
            <div>
				Явное приведение считается небезопастным<br/>
				Неявное приведение считается безопастным<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="variativnost">
                List наследуется от двух интерфейсов - IList и IEnumerable. Почему List&lt;string&gt;можно привести к
                IEnumerable&lt;object&gt;, а к IList&lt;object&gt; нельзя?<br />
            </div>
            <div>
                <div class="link"> http://professorweb.ru/my/csharp/charp_theory/level11/11_14.php </div>
                <b>Ковариация</b> – out, значит указанный тип является максимальным в цепочке наследования, кт. могут 
                передаваться. Используется для возвращаемых значений.<br/>
                <b>Контравариация</b> – in, значит указанный тип является минимальным в цепочке наследования, кт. могут 
                передаваться. Используется для входящих значений.<br/>
                <b>Инвариация</b> – позволяет использовать только заданный тип<br />
                <div class="link"> https://habrahabr.ru/post/218753/ </div>
            </div>
        </li>
        <li>
            <div class="questiion" id="variacia">С чем можно использовать вариацию?</div>
            <div>
                <b>Вариация</b> может применяться только к делегатам и интерфейсам
            </div>
        </li>
        <li>
            <div class="questiion" id="genericconstraint">Расскажите про ограничения обобщенных типов</div>
            <div>
                Ограничение сужает перечень типов, которые можно передать в обобщенном аргументе.<br/>
				public static T Min&lt;T&gt;(T o1, T o2) where T : class where T : IComparable&lt;T&gt; {...}<br/>
				Маркер where в C# сообщает компилятору, что указанный в T тип должен быть классом и реализовывать обобщенный
				интерфейс IComparable того же типа (T).<br/>
				К параметру-типу могут применяться следующие ограничения: <br/>
				<b>основное (primary)</b>, бывают class и struct. Можно задать одно основное ограничение<br/>
				<b>дополнительное (secondary)</b>, можно задать несколько доп ограничений <br/>
				<b>ограничение конструктора (constructor constraint)</b>, можно задать не более одного ограничения
				конструктора. <br/>
				<b>System.Nullable&lt;T&gt;</b> или значимые типы с поддержкой null не подходят под это ограничение.
            </div>
        </li>
        <li>
            <div class="questiion" id="overridegenericы">
				Как происходит перегрузка обощенных классов и методов?<br />
			</div>
            <div>
                Среда CLR не поддерживает перегрузку по именам параметров типа или по именам ограничений. Перегрузка типов и методов выполняется только по арности.<br/>
				internal sealed class AType {}<br/>
				internal sealed class AType&lt;T&gt; {}<br/>
				internal sealed class AType&lt;T1, T2&gt; {}<br/>
				При переопределении виртуального обобщенного метода в переопределяющем методе должно быть задано то же число
				параметров-типов, а они, в свою очередь, наследуют ограничения, заданные для них методом базового класса. 
				Переопределяемый метод не вправе задавать ограничения для своих параметров-типов, но может переименовывать параметры-типы.<br/>
				internal class Base <br/>
				{<br/>
					public virtual void M&lt;T1, T2&gt;()<br/>
						where T1 : struct<br/>
						where T2 : class <br/>
					{...}<br/>
				}<br/>
				internal sealed class Derived : Base <br/>
				{<br/>
					public override void M&lt;T3, T4&gt;()<br/>
						where T3 : EventArgs // Ошибка<br/>
						where T4 : class     // Ошибка<br/>
					{...}<br/>
				}<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="explicitinterface">
                Для чего используется объявление метода в классе явно вместе с сигнатурой интерфейса?<br />
            </div>
            <div>
                Чтобы вызвать этот метод через интерфейсную ссылку. При явной реализации метода, он по умолчанию private
            </div>
        </li>
        <li>
            <div class="questiion" id="nondispose">
                Приведите пример, как можно “засорить” память приложения?<br />
            </div>
            <div>

            </div>
        </li>
        <li>
            <div class="questiion" id="jit">
                Что такое JIT компилятор? Для чего он нужен?<br />
            </div>
            <div>
                Это just-in-time компилятор кт. компилирует код в процессе его выполнения.<br />
                Для компилирования IL-кода в процессе работы приложения.<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="metadata">
                Что такое метаданные и что такое манифест?<br />
            </div>
            <div>
                <b>Метаданные</b> — это блок двоичных данных, состоящий из нескольких таблиц. Существуют три категории таблиц:
                определений, ссылок и манифестов<br />
                Рихтер - несколько слов о метаданных<br />
                Файл Program.exe — это не просто PE-файл с метаданными, а еще и сборка (assembly), то есть совокупность
                одного или нескольких файлов с определениями типов и файлов ресурсов. Один из файлов сборки выбирается
                для хранения ее манифеста. Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном
                содержат имена файлов, составляющих сборку. Кроме того, эти таблицы описывают версию и региональные
                стандарты сборки, ее издателя, общедоступные экспортируемые типы, а также все составляющие сборку файлы.
                <br />Рихтер - Объединение модулей для создания сборки
            </div>
        </li>
        <li>
            <div class="questiion" id="bixingunboxing">
                Что такое boxing and unboxing? Когда она происходит?<br />
            </div>
            <div>
                --Упаковка<br />
                Для преобразования значимого типа в ссылочный служит упаковка (boxing). При упаковке экземпляра значимого
                типа происходит следующее.<br />
                1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя
                дополнительными членами — указателем на типовой объект(type object pointer) и индексом блока
                синхронизации(syncblock index). Эти члены необходимы для всех объектов в управляемой куче.<br />
                2. Поля значимого типа копируются в память, только что выделенную в куче.<br />
                3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается
                в ссылочный.<br />
                --Распаковка<br />
                Point p = (Point) a[0];<br />
                Здесь ссылка (или указатель), содержащаяся в элементе с номером 0 массива ArrayList, помещается в <br />
                переменную p значимого типа Point. Для этого все поля, содержащиеся в упакованном объекте Point, надо
                скопировать в переменную p значимого типа, находящуюся в стеке потока. CLR выполняет эту процедуру в два
                этапа.<br />
                1. Сначала извлекается адрес полей Point из упакованного объекта Point. Этот процесс называют
                распаковкой (unboxing).<br />
                2. Затем значения полей копируются из кучи в экземпляр значимого типа, находящийся в стеке.<br />
                Распаковка не является точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем
                упаковка, и состоит только в получении указателя на исходный значимый тип (поля данных), содержащийся в
                объекте. В сущности, указатель ссылается на неупакованную часть упакованного экземпляра, и никакого
                копирования при распаковке (в отличие от упаковки) не требуется. Однако вслед за распаковкой обычно
                выполняется копирование полей.<br />
                При распаковке упакованного значимого типа происходит следующее.<br />
                1. Если переменная, содержащая ссылку на упакованный значимый тип, равна null, генерируется исключение
                NullReferenceException.<br />
                2. Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа,
                генерируется исключение InvalidCastException.<br />
                Из второго пункта следует, что приведенный ниже код не работает так, как хотелось бы:<br />
                public static void Main()<br />
                {<br />
                &nbsp;&nbsp;Int32 x = 5;<br />
                &nbsp;&nbsp;Object o = x; // Упаковка x; o указывает на упакованный объект<br />
                &nbsp;&nbsp;Int16 y = (Int16) o; // Генерируется InvalidCastException<br />
                &nbsp;&nbsp;Int16 y = (Int16)(Int32) o; // Распаковка, а затем приведение типа<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="changeprivatevar">
                *Как можно изменить private поле у объекта во время runtime в обход компилятора?<br />
            </div>
            <div>
				С помощью рефлексии
            </div>
        </li>
        <li>
            <div class="questiion" id="internirovanie">
                Что такое Интернирование строк?<br />
            </div>
            <div>
                <b>Интернирование строк</b> — это механизм, при котором одинаковые литералы представляют собой один объект в
                памяти. В рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя
                хеш-таблица, ключами которой являются строки, а значениями – ссылки на них. Во время JIT-компиляции
                литеральные строки последовательно заносятся в таблицу (каждая строка в таблице встречается только один
                раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы. Можно поместить
                строку во внутреннюю таблицу во время выполнения с помощью метода String.Intern. Также можно проверить,
                содержится ли строка во внутренней таблице с помощью метода String.IsInterned.
            </div>
        </li>
        <li>
            <div class="questiion" id="concurentcollection">
                Потокобезопастные коллекции<br />
            </div>
            <div>
                <b>ConcurrentQueue&lt;T&gt;</b><br />
                Этот класс коллекции реализован со свободным от блокировок алгоритмом и использует 32 массива, которые
                внутренне скомбинированы в связный список. Для доступа к элементам очереди применяются методы Enqueue(),
                TryDequeue() и TryPeek(). Имена этих методов очень похожи на уже известные методы Queue&lt;T&gt;, но с 
				добавлением префикса Try к тем из них, которые могут дать сбой. Поскольку этот класс реализует
                интерфейс IProducerConsumerCollection&lt;T&gt;, методы TryAdd() и TryTake() просто вызывают Enqueue() и
                TryDequeue().<br />
                <b>ConcurrentStack&lt;T&gt;</b><br />
                Очень похож на ConcurrentQueue&lt;T&gt;, но с другими методами доступа к элементам. Класс
                ConcurrentStack&lt;T&gt; определяет методы Push(), PushRange(), TryPeek(), TryPop() и TryPopRange().
                Внутри этот класс использует связный список для хранения элементов. ConcurrentBag&lt;T&gt;Этот класс не
                определяет никакого порядка для добавления или извлечения элементов. Он реализует концепцию отображения
                потоков на используемые внутренне массивы, и старается избежать блокировок. Для доступа к элементам
                применяются методы Add(), TryPeek() и TryTake().<br />
                <b>ConcurrentDictionary&lt;TKey, TValue&gt;</b><br />
                Безопасная в отношении потоков коллекция ключей и значений. Для доступа к членам в неблокирующем режиме
                служат методы TryAdd(), TryGetValue(), TryRemove() и TryUpdate(). Поскольку элементы основаны на ключах и
                значениях, ConcurrentDictionary&lt;TKey, TValue&gt; не реализует интерфейс
                IProducerConsumerCollection&lt;T&gt;.<br />
                <b>ConcurrentXXX</b><br />
                Эти коллекции безопасны к потокам в том смысле, что возвращают false, если какое-то действие над ними
                невозможно при текущем состоянии потоков. Прежде чем предпринимать какие-то дальнейшие действия, всегда
                следует проверять успешность добавления или извлечения элементов. Полностью доверять коллекции решение
                задачи нельзя.<br />
                <b>BlockingCollection&lt;T&gt;</b><br />
                Коллекция, которая осуществляет блокировку и ожидает, пока не появится возможность выполнить действие по
                добавлению или извлечению элемента. BlockingCollection&gt;T&gt; предлагает интерфейс для добавления и
                извлечения элементов методами Add() и Take(). Эти методы блокируют поток и затем ожидают, пока не
                появится возможность выполнить задачу. Метод Add() имеет перегрузку, которой можно также передать
                CancellationToken. Эта лексема всегда отменяет блокирующий вызов. Если не нужно, чтобы поток ожидал
                бесконечное время, и не хотите отменять вызов извне, доступны также методы TryAdd() и TryTake(). В них
                можно указать значение таймаута — максимального периода времени, в течение которого вы готовы блокировать
                поток и ждать, пока вызов не даст сбой.
            </div>
        </li>		
        <li>
            <div class="questiion" id="accessmodifiers">
                Модификаторы доступа <br />
            </div>
            <div>
			<b>public</b> - публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок. <br/>
			<b>private</b> - закрытый класс или член класса. Представляет полную противоположность модификатору <b>public</b>. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте. <br/>
			<b>protected</b> - такой член класса доступен из любого места в текущем классе или в производных классах. <br/>
			<b>internal</b> - класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public). <br/>
			<b>protected internal</b> - совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов. <br/>
            </div>
        </li>
    </ul>

    <div class="theme" id="sqlquestion">Вопросы по MS SQL</div>
    <div>
        <a href="#tsql">Что такое T-SQL?</a><br />
        <a href="#normalization">Нормализация</a><br />
        <a href="#temptable">Temp table</a><br />
        <a href="#isolation">Виды изоляций транзакций?</a><br />
        <a href="#spvsudf">Что такое хранимая процедура? В чем отличие от функции?</a><br />
        <a href="#view">Что такое View</a><br />
        <a href="#heap">Расскажите про Кучу?</a><br />
        <a href="#indexes">Что такое индексы? Какие типы индексов вы знаете? Для чего нужны?</a><br />
        <a href="#clustered">Расскажите про структуру кластерного индекса?</a><br />
        <a href="#nonclustered">Расскажите про структуру некластерного индекса?</a><br />
        <a href="#columnstore">Расскажите про columnstore index?</a><br />
        <a href="#xmlindex">Расскажите про XML index?</a><br />
        <a href="#otherindexes">Какие еще типы индексов вы знаете?</a><br />
        <a href="#constraint">Что такое Constraint? Какие Constraint вам известны и какую роль они выполняют?</a><br />
        <a href="#triggers">Что такое триггеры?</a><br />
        <a href="#joins">Что такое LEFT JOIN, RIGHT JOIN, INNER JOIN</a><br />
        <a href="#hints">Для чего нужны hints (подсказки или указания) в sql?</a><br />
        <a href="#scantable">Что такое Full Table Scan? Как этого можно избежать?</a><br />
        <a href="#sqltransaction">Что дает SQL транзакция?</a><br />
        <a href="#denormalization">
            Для чего используется денормализация базы данных?
            Приходилось ли вам денормализировать базу данных?
        </a><br />
        <a href="#computedcolumn">
            Расскажите, из чего состоит строка в таблице, содержащей две колонки типа nvarchar и int?
            Какие дополнительные данные содержатся в этой строке?
        </a><br />
        <a href="#extent">Что такое Extent?</a><br />
        <a href="#multithreading">Как реализовать многопоточность в MS SQL?</a><br />
        <a href="#surrogatekey">Что такое натуральный и суррогатный ключ?</a><br />
        <a href="#referentialintegrity">Что такое ссылочная целостность? Какие способы ее организации можете назвать?</a><br />
        <a href="#relationvsobject">Что такое реляционная модель? Отличие от объектной</a><br />
        <a href="#aaaa"></a><br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="tsql">
                Что такое T-SQL?
            </div>
            <div>
                <b>Transact-SQL (T-SQL)</b> — процедурное расширение языка SQL, созданное компанией Microsoft (для Microsoft SQL Server) и Sybase (для Sybase ASE).
            </div>
        </li>
        <li>
            <div class="questiion" id="normalization">Нормализация</div>
            <div>
                <div class="link"> https://habrahabr.ru/post/254773/ </div>
                <b>Атрибут</b> — свойство некоторой сущности. Часто называется полем таблицы.<br />
                <b>Домен атрибута</b> — множество допустимых значений, которые может принимать атрибут.<br />
                <b>Кортеж</b> — конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе
                описывают некоторую сущность (строка таблицы).<br />
                <b>Отношение</b> — конечное множество кортежей (таблица).<br />
                <b>Первая нормальная форма</b><br />
                Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны
                содержать только скалярные значения. Не должно быть повторений строк в таблице.<br />
                <b>Вторая нормальная форма</b><br />
                Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от
                Первичного Ключа(ПК).<br />
                Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к
                нескольким записям таблицы в отдельные таблицы.<br />
                <b>Третья нормальная форма</b><br />
                Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от
                первичного ключа.
            </div>
        </li>
        <li>
            <div class="questiion" id="temptable">Temp table</div>
            <div>
				Temptable бывают следующих видов:<br/>
				- #tempTable - хранятся в tempDB, не может использоваться повторно<br/>
				- ##tempTable - хранятся в tempDB, но может использоваться повторно<br/>
				- @tempTable - табличная переменная. Время жизни - это рамки процедуры или функции
            </div>
        </li>
        <li>
            <div class="questiion" id="isolation">Виды изоляций транзакций?</div>
            <div>
                <div class="link"> https://habrahabr.ru/company/infopulse/blog/261097/ </div>
                <b>
                    Read Uncommitted<br />
                    Проблема – Lost Update<br />
                </b>
                Две транзакции выполняют одновременно UPDATE для одной и той же строки, и изменения, сделанные одной
                транзакцией, затираются другой.<br />
                <table>
                    <tr>
                        <th style="">tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>UPDATE tbl1 SET f2=f2+20 WHERE f1=1;</td>
                        <td>UPDATE tbl1 SET f2=f2+10 WHERE f1=1;</td>
                    </tr>
                </table>
                <b>
                    Read Committed (Default)<br />
                    Проблема - Dirty read<br />
                </b>
                Это такое чтение, при котором могут быть считаны добавленные или изменённые данные из другой транзакции,
                которая впоследствии не подтвердится (откатится). Так как данный эффект возможен только при минимальном
                уровне изоляции, а по умолчанию используется более высокий уровень изоляции (READ COMMITTED), то в
                скрипте чтения данных уровень изоляции будет явно установлен как READ UNCOMMITTED. Если вернуть уровень
                изоляции по умолчанию (READ COMMITTED) для транзакции 2, то поведение поменяется.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>UPDATE</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>SELECT</td>
                    </tr>
                    <tr>
                        <td>ROLLBACK</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>SELECT</td>
                    </tr>
                </table>
                <b>
                    Repeatable Read<br />
                    Проблема – non-repeatable read<br />
                </b>
                Проявляется, когда при повторном чтении в рамках одной транзакции, ранее прочитанные данные, оказываются
                изменёнными. Данный эффект может наблюдаться при уровне изоляции ниже, чем REPEATABLE READ.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>UPDATE</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>COMMIT</td>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                </table>
                <b>
                    Serializable<br />
                    Проблема – phantom reads<br />
                </b>
                Можно наблюдать, когда одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по
                одним и тем же критериям. При этом другая транзакция в интервалах между этими выборками добавляет или
                удаляет строки, или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции,
                и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные
                множества строк. Данный эффект можно наблюдать, когда уровень изоляции ниже чем SERIALIZABLE.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>INSERT</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>COMMIT</td>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="spvsudf">Что такое хранимая процедура? В чем отличие от функции?</div>
            <div>
                <b>хранимая процедура</b> - упорядоченная последовательность операторов T-SQL, оформленных в виде единого
                логического модуля. В ХП допускается использование переменных и параметров, а также операторов управления
                ходом выполнения и циклических конструкций.<br />
                <b>UDF</b> - это подпрограмма, которая принимает на вход параметры, обрабатывает их и возвращает результат.
                Результат может быть как скаляром, так и таблицей.
                <div class="link"> http://stackoverflow.com/questions/1179758/function-vs-stored-procedure-in-sql-server </div>
                A Function can be used inline in SQL Statements if it returns a scalar value or can be joined upon if
                it returns a result set.
                Functions are computed values and cannot perform permanent environmental changes to SQL Server
                (i.e. no INSERT or UPDATE statements allowed).
                The difference between SP and UDF is listed below:
                <table>
                    <tr>
                        <th>Stored Procedure (SP)</th>
                        <th>Function (UDF - User Defined Function)</th>
                    </tr>
                    <tr>
                        <td>We can't use SP in SELECT/WHERE/ HAVING statement</td>
                        <td>We can use UDF in SELECT/WHERE/ HAVING statement</td>
                    </tr>
                    <tr>
                        <td>SP can use update, insert, delete</td>
                        <td>Functions are computed values</td>
                    </tr>
                    <tr>
                        <td>SP can return zero, single or multiple values</td>
                        <td>Function can return one value which is mandatory</td>
                    </tr>
                    <tr>
                        <td>We can use transaction in SP</td>
                        <td>We can't use transaction in UDF</td>
                    </tr>
                    <tr>
                        <td>SP can have input/output parameter</td>
                        <td>Only input parameter</td>
                    </tr>
                    <tr>
                        <td>We can call function from SP.</td>
                        <td>We can't call SP from function</td>
                    </tr>
                    <tr>
                        <td>We can use exception handling using Try-Catch block in SP</td>
                        <td>We can't use Try-Catch block in UDF</td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="view">Что такое View?</div>
            <div>
                <b>Представление (view)</b> — это объект реляционной базы данных, который описывает виртуальную
                таблицу.<br />
                <b>Представление (view)</b> — это хранимый запрос SELECT любой сложности, при выполнении которого
                получается виртуальная таблица, которая физически в базе данных не хранится.<br />
                При использовании представления можно изменять данные в базовых таблицах представления.<br />
                Изменениям подлежат только значения "обычных" столбцов.<br />
                Нельзя изменить значение вычисляемого столбца.<br />
                Разумеется, нет возможности внести изменения в данные, полученные при помощи агрегатных функций.<br />
                Нельзя при помощи представления добавить новую строку в базовую таблицу, если в списке выбора не
                присутствуют все столбцы, входящие в состав первичного ключа. При этом если первичный ключ описан с
                характеристикой IDENTITY и он не присутствует в списке выбора представления, то добавление новых строк
                возможно.<br />
                Представления могут быть индексированными. Для представления допустимо создание уникального
                кластерного индекса. В этом случае результирующий набор данных представления будет физически
                храниться в базе данных. Изменения в базовой таблице, связанные со столбцами, входящими в состав
                такого индекса, приведут к выполнению соответствующих изменений в индексе.<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="heap">Расскажите про Кучу?</div>
            <div>
                <b>Кучи</b> – это данные, хранящиеся без какой-либо определенной сортировки, не имеющие кластерных индексов,
                доступ и поиск по таким данным происходит последовательно при сканировании страниц, и может занимать
                довольно долгое время влияя негативно на производительность.
            </div>
        </li>
        <li>
            <div class="questiion" id="indexes">Что такое индексы? Какие типы индексов вы знаете? Для чего нужны?</div>
            <div>
                <b>Индекс (англ. index)</b> — объект базы данных, создаваемый с целью повышения производительности
                поиска данных.<br />
                - Clustered Index — кластерный индекс;<br />
                - Non-Clustered Index — некластерный индекс;<br />
                - Columnstore index - индекс для столбцов;<br />
                - XML index - индекс для XML;<br />
                <div class="link"> https://habrahabr.ru/post/247373/ </div>
            </div>
        </li>
        <li>
            <div class="questiion" id="clustered">Расскажите про структуру кластерного индекса?</div>
            <div>
                <b>Кластеризованный индекс</b> организован в виде сбалансированного дерева и хранит реальные строки
                данных в листьях индекса. Важной характеристикой кластеризованного индекса является то, что все
                значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица
                или представление может иметь только один кластеризованный индекс. В дополнение следует отметить, что
                данные в таблице хранятся в отсортированном виде только в случае если создан кластеризованный индекс у
                этой таблицы.
            </div>
        </li>
        <li>
            <div class="questiion" id="nonclustered">Расскажите про структуру некластерного индекса?</div>
            <div>
                <b>Некластеризованный индекс</b> организован в виде сбалансированного дерева и не содержит реальных
                данных таблицы в узлах-листьях. Это означает, что системе подзапросов необходима дополнительная
                операция для обнаружения и получения требуемых данных. Содержание указателя на данные зависит от
                способа хранения данных: <b>кластеризованная таблица или куча</b>.<br />
                1 - Если в таблице не создан кластеризованный индекс, то некластеризованные индексы по этой таблице
                хранят в своих узлах-листьях <b>идентификаторы строк</b>. Идентификатор строки указывает на реальную строку
                данных в таблице, по сути это - значение, включающее в себя номер файла данных, номер страницы и
                местоположение строки на этой странице.<br />
                2 - Если в таблице создан кластеризованный индекс, то некластеризованные индексы содержат в узле-листе
                <b>значение ключа кластеризованного индекса</b> для этих данных. При достижении узла-листа некластеризованного
                индекса находящееся в нем значение кластеризованного ключа используется для поиска в кластеризованном
                индексе, соответствующий узел-лист которого содержит искомую строку данных.<br>
                Возможно, создать до 999 некластеризованных индексов на одну таблицу.
            </div>
        </li>
        <li>
            <div class="questiion" id="columnstore">Расскажите про columnstore index?</div>
            <div>
                <b>Columnstore index</b><br />
                <b>Индексы columnstore</b> появились в версии SQL Server 2012. Основное его отличие от обычного,
                "реляционного", классического (rowstore) заключается в способе формирования и в форме хранения.<br />
                На одной таблице может быть создан только один колоночный индекс.<br />
                При создании обычного индекса группируются и сохраняются данные для строк. Для индекса columnstore
                выполняется группировка и сохранение данных для столбцов. При этом выполняется сжатие данных. Кроме
                того, индекс может создаваться только для таблиц, но не для представлений. Данные таблицы, для которой
                создан индекс columnstore, не могут быть изменены. <br />
                Для некоторых типов запросов к базе такая структура индекса может сильно повысить производительность.
                Подобные запросы часто используются при работе с так называемыми хранилищами данных.<br />
                В индекс могут быть включены типы данных: строковые, числовые, даты и времени. Нельзя включать
                разреженные столбцы. Индекс не может содержать более 1024 столбцов.
            </div>
        </li>
        <li>
            <div class="questiion" id="xmlindex">Расскажите про XML index?</div>
            <div>
                <b>XML-индекс</b> индексирует все теги, значения и пути хранимые в столбце экземпляров XML. Для одной таблицы
                можно создать до 249 индексов XML.<br />
                XML-индексы разделяются на следующие категории.<br />
                <b>Первичный</b> XML-индекс<br />
                <b>Вторичные</b> XML-индексы.<br />
                <b>Первичный XML-индекс</b><br />
                При создании первичного XML-индекса индексируются все теги, значения и пути в экземплярах XML,
                хранимых в XML-столбце. Чтобы создать первичный XML-индекс, таблица, содержащая соответствующий
                XML-столбец, должна иметь кластеризованный индекс первичного ключа таблицы.<br />
                <b>ВторичныеXML-индексы</b><br />
                Перед созданием вторичных индексов должен существовать первичный XML-индекс. Существуют следующие типы
                вторичных индексов: PATH, VALUE, PROPERTY<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="otherindexes">Какие еще типы индексов вы знаете?</div>
            <div>
                <b>Составной индекс</b><br />
                Такой индекс может содержать более одного столбца. Вы можете включить до 16 столбцов в индекс, но их
                общая длина ограничена 900 байтами. Как кластеризованный, так и некластеризованный индексы могут быть
                составными.<br />
                <b>Уникальный индекс</b><br />
                Такой индекс обеспечивает уникальность каждого значения в индексируемом столбце.<br />
                <b>Покрывающий индекс</b><br />
                Такой индекс позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без
                дополнительных обращений к записям самой таблицы.<br />
                <b>Фильтрованный индекс</b><br />
                В операторе создания индекса можно указать предложение WHERE, которое определяет создание
                "фильтрованного" индекса. В состав, которого включаются не все строки таблицы, а только те, которые
                отвечают условиям, заданным в этом предложении. Такой фильтрованный индекс не может быть кластерным.
            </div>
        </li>
        <li>
            <div class="questiion" id="constraint">
                Что такое Constraint? Какие Constraint вам известны и какую роль они выполняют?
            </div>
            <div>
                - <b>Constraint</b> – универсальное средство, с помощью которого можно задать правила, которым должны
                удовлетворять данные, для возможности записи в поле. Если записываемое значение не удовлетворяет
                ограничениям, назначенным полю, то запись завершается ошибкой. Таким образом, сервер сам будет
                контролировать целостность данных, вводимых пользователем.<br>
                - <b>NOT NULL</b> - Indicates that a column cannot store NULL value<br>
                - <b>UNIQUE</b> - Ensures that each row for a column must have a unique value<br>
                - <b>PRIMARY KEY</b> - A combination of a NOT NULL and UNIQUE. Ensures that a column (or combination of two or
                more columns) have a unique identity which helps to find a particular record in a table more easily and
                quickly<br>
                - <b>FOREIGN KEY</b> - Ensure the referential integrity of the data in one table to match values in another
                table<br>
                - <b>CHECK</b> - Ensures that the value in a column meets a specific condition<br>
                - <b>DEFAUL</b>T - Specifies a default value for a column<br>
            </div>
        </li>
        <li>
            <div class="questiion" id="triggers">Что такое триггеры?</div>
            <div>
                <b>Три́ггер (англ. trigger)</b> — это хранимая процедура особого типа, которую пользователь не вызывает
                непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT,
                удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце
                заданной таблицы. Могут выполняться как до операции, так и после.
            </div>
        </li>
        <li>
            <div class="questiion" id="joins">Что такое LEFT JOIN, RIGHT JOIN, INNER JOIN, CROSS JOIN</div>
            <div>
                Объеденяет таблицы для получения результатов<br/>
				SELECT * FROM Table1 t1<br/>
				(LEFT/RIGHT/INNER) JOIN Table2 t2 ON t1.ID = t2.ID<br/>
				SELECT * FROM Table1 t1<br/>
				CROSS JOIN Table2 t2<br/>
				Результат:<br/>
				<b>LEFT</b> Все строки из t1, из t2, те что соответствуют ON или NULL<br/>
				<b>RIGHT</b> Все строки из t2, из t1, те что соответствуют ON или NULL<br/>
				<b>INNER</b> Те строки из t1 и t2, что соответствуют ON<br/>
				<b>CROSS</b> Каждой строке из t1, соответствуют все строки из t2<br/>				
            </div>
        </li>
        <li>
            <div class="questiion" id="hints">Для чего нужны hints (подсказки или указания) в sql?</div>
            <div>
                Подсказка в языке SQL (англ. hint) — средство, позволяющее явным образом влиять на план запроса.
                Выделяются следующие назначения подсказок:<br />
                указание порядка соединения таблиц<br />
                указание метода соединения таблиц<br />
                указание конкретного индекса для доступа к таблице<br />

                SELECT *<br />
                FROM Customers C WITH (INDEX=City)<br />
                INNER LOOP JOIN Orders O ON O.CustomerID = C.CustomerID<br />
                WHERE C.City = 'Madrid'<br />
                фигурируют две подсказки:<br />
                LOOP — указывает, что соединять таблицы следует методом вложенных циклов<br />
                WITH (INDEX=City) — указывает, что для доступа к таблице Customers следует использовать индекс с названием City
            </div>
        </li>
        <li>
            <div class="questiion" id="scantable">Что такое Full Table Scan? Как этого можно избежать?</div>
            <div>
                Последовательный поиск данных, может занимать довольно долгое время влияя негативно на производительность.
            </div>
        </li>
        <li>
            <div class="questiion" id="sqltransaction">Что дает SQL транзакция?</div>
            <div>
                <b>Транзакция</b> – это последовательность операций, которые должны быть или все выполнены или все не
                выполнены (все или ничего).
            </div>
        </li>
        <li>
            <div class="questiion" id="denormalization">
                Для чего используется денормализация базы данных?
                Приходилось ли вам денормализировать базу данных?
            </div>
            <div>Чтобы избежать JOIN’ов</div>
        </li>
         <li>
            <div class="questiion" id="computedcolumn">
                Расскажите, из чего состоит строка в таблице, содержащей две колонки типа nvarchar и int?
                Какие дополнительные данные содержатся в этой строке?
            </div>
            <div>
                ??? Вычисляемый столбец <b>(computed column)</b>. Int нужно будет приводить к nvarchar
            </div>
        </li>       
		<li>
            <div class="questiion">Какая структура (архитектура) .mdl файла?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Как хранятся таблицы в .mdl файлах?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion" id="extent">Что такое Extent?</div>
            <div>
			
			<b>Cтраница</b> - это основная единица хранилища данных в SQL Server. Место на диске, предоставляемое для размещения файла данных (MDF- или NDF-файл) в базе данных, логически разделяется на страницы с непрерывным перечислением от 0 до n. Дисковые операции ввода-вывода выполняются на уровне страницы. А именно, SQL Server считывает или записывает целые страницы данных.<br/>
			
			<b>Extent</b> — это коллекция, состоящая из восьми физически непрерывных страниц; они используются для эффективного управления страницами. Все страницы хранятся в экстентах.</div>			
            <div class="link"> https://technet.microsoft.com/ru-ru/library/ms190969(v=sql.105).aspx </div>
			
        </li>
        <li>
            <div class="questiion" id="multithreading">Как реализовать многопоточность в MS SQL?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion" id="surrogatekey">Что такое натуральный и суррогатный ключ?</div>
            <div>
			<b>Натуральный ключ</b> - это один или несколько атрибутов сущности, которые являются уникальными по природе задачи.<br/>
			<b>Суррогатный Ключ (СК)</b> – автоматически сгенерированное поле, никак не связанное с информационным содержанием записи. Обычно в роли СК выступает автоинкрементное поле типа INTEGER.
			</div>
        </li>
        <li>
            <div class="questiion" id="referentialintegrity">
				Что такое ссылочная целостность? Какие способы ее организации можете назвать?
			</div>
            <div>
			<b>Cсылочная целостность</b> означает, что внешний ключ в одной таблице всегда должен ссылаться на действительную строку в другой таблице. <b>Cсылочная целостность</b> гарантирует, что связь между двумя таблицами остается синхронизированной во время обновлений и удалений.<br/>
			<b>Foreign key</b>
			</div>
        </li>
        <li>
            <div class="questiion" id="relationvsobject">
				Что такое реляционная модель? Отличие от объектной
			</div>
            <div>
			<b>Реляционная модель</b> представляет собой совокупность данных, состоящую из набора двумерных таблиц. В теории множеств таблице соответствует термин отношение <b>(relation)</b>, физическим представлением которого является таблица, отсюда и название модели – <b>реляционная</b>.<br/>
			<div class="link"> https://habrahabr.ru/post/93356/ </div>			
			</div>
        </li>
    </ul>

    <div class="theme" id="patternsquestion">Вопросы по шаблонам проектирования</div>
    <div>
        <a href="#spagettycode">Что такое Spagetty Code?</a><br />
        <a href="#raviolicode">Что такое Ravioli code?</a><br />
        <a href="#spagettycode">Что такое Lasagna code?</a><br />
        <a href="#typeofpatterns">Какие шаблоны проектирования известны?</a><br />
        <a href="#factory">Что такое фабрика?</a><br />
        <a href="#strategy">Что такое стратегия?</a><br />
        <a href="#adapter">Что такое адаптер?</a><br />
        <a href="#dependencyinjection">Что такое Dependency Injection?</a><br />
        <a href="#ioc">Что такое IoC?</a><br />
        <a href="#publishersubscriber">
            Реализацией какого паттерна являются события в .NET? (Publisher - Subscriber)
        </a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
		<li>
            <div class="questiion" id="spagettycode">Что такое Spagetty Code?</div>
            <div>
                <b>Спагетти-код</b> — плохо спроектированная, слабо структурированная, запутанная и трудная для понимания
                программа. <br />
                Спагетти-код назван так, потому что ход выполнения программы похож на миску спагетти, то есть
                извилистый и запутанный.
            </div>
        </li>
        <li>
            <div class="questiion" id="raviolicode">Что такое Равиоли-код?</div>
            <div>
                <b>Равиоли-код</b> — код, состоящий из огромного числа независимых компонентов, и чтобы понять, как исправить ошибку на стыке компонентов, надо «прорываться» через межкомпонентные интерфейсы.
            </div>
        </li>
        <li>
            <div class="questiion" id="pahlavacode">Что такое Пахлава-код или лазанья-код?</div>
            <div>
                <b>Пахлава-код</b> или <b>лазанья-код</b> — код, в котором слишком много (для данной задачи) слоёв абстракции.
            </div>
        </li>
        <li>
            <div class="questiion" id="typeofpatterns">Какие шаблоны проектирования известны?</div>
            <div>
                <table>
                    <tr>
                        <th>Поведенчиские (Behavioral)</th>
                        <td>Chain Of Responsibility</td>
                        <td>Command</td>
                        <td>Interpreter</td>
                        <td>Iterator</td>
                        <td>Mediator</td>
                        <td>Memento</td>
                        <td>Observer</td>
                        <td>Strategy</td>
                        <td>Template Method</td>
                        <td>State</td>
                        <td>Visor</td>
                    </tr>
                    <tr>
                        <th>Порождающие (Creational)</th>
                        <td>Abstract factory</td>
                        <td>Builder</td>
                        <td>Factory Method</td>
                        <td>Prototype</td>
                        <td>Singleton</td>
                    </tr>
                    <tr>
                        <th>Структурные (Structural)</th>
                        <td>Adapter</td>
                        <td>Bridge</td>
                        <td>Composite</td>
                        <td>Decorator</td>
                        <td>Facade</td>
                        <td>Flyweight(приспособленец)</td>
                        <td>Proxy</td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="factory">Что такое фабрика?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion" id="strategy">Что такое стратегия?</div>
            <div>
                <b>Стратегия (англ. Strategy)</b> — поведенческий шаблон проектирования, предназначенный для определения
                семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет
                выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять
                выбранный алгоритм независимо от объектов-клиентов, которые его используют.
            </div>
        </li>
        <li>
            <div class="questiion" id="adapter">Что такое адаптер?</div>
            <div>
                <b>Адаптер (англ. Adapter)</b> — структурный шаблон проектирования, предназначенный для организации
                использования функций объекта, недоступного для модификации, через специально созданный интерфейс.
                Имеется посредник, кт. выдает поведение вспомогательного класса, за основное
            </div>
        </li>
        <li>
            <div class="questiion" id="dependencyinjection">Что такое Dependency Injection?</div>
            <div>
                Внедрения зависимости позволяет нам автоматически вытянуть из IoC-контейнера нужные нам зависимости
                при инициализации.
            </div>
        </li>
        <li>
            <div class="questiion" id="ioc">Что такое IoC?</div>
            <div>
                <b>Inversion of Control (инверсия управления)</b> - это паттерн, в котором управление временем жизни объекта
                поручено какой-то компоненте. Вместо того чтобы создавать объект самим (через new()) мы запрашиваем
                его у т.н. IoC-контейнера, то есть у фабрики, которая умеет грамотно производить объекты.
            </div>
        </li>
        <li>
            <div class="questiion" id="publishersubscriber">
                Реализацией какого паттерна являются события в .NET? (Publisher - Subscriber)
            </div>
            <div>Observer(Наблюдатель)</div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion">
            </div>
            <div></div>
        </li>
    </ul>

    <div class="theme" id="testingquestion">Вопросы по Unit Tests</div>
    <div>
        <a href="#typeoftest">Виды тестирования?</a><br />
        <a href="#unittests">Для чего нужны Unit tests?</a><br />
        <a href="#mock">Что такое Mock объект?</a><br />
        <a href="#aaaa"></a><br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="typeoftest">Виды тестирования?</div>
            <div>
                <b>Блочное (модульное, unit testing)</b> - тестирование наиболее понятное для программиста. Фактически
                это тестирование методов какого-то класса программы в изоляции от остальной программы.<br />
                <b>Интеграционное (Integration Testing)</b> — тестирование взаимодействия нескольких классов, выполняющих
                вместе какую-то работу.<br />
                <b>Системное (System Testing)</b> — тестирование программы в целом.
            </div>
        </li>
        <li>
            <div class="questiion" id="unittests">Для чего нужны Unit tests?</div>
            <div>Для тестирования методов какого-то класса</div>
        </li>
        <li>
            <div class="questiion" id="mock">Что такое Mock объект?</div>
            <div>
                <b>Mock-объект</b> представляет собой конкретную фиктивную реализацию интерфейса, предназначенную
                исключительно для тестирования взаимодействия и относительно которого высказывается утверждение.
            </div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
    </ul>

    <div class="theme" id="mvcquestion">Вопросы по ASP.NET MVC</div>
    <div>
        <a href="#aboutmvc">
            Что такое MVC? Рассказать про архитектуру ASP.NET MVC (action методы, вьюхи, контроллеры,
            общий цикл жизни запроса).
        </a><br />
        <a href="#webconfig">Для чего служит web.config?</a><br />
        <a href="#globalasax">Для чего используется Global.asax?</a><br />
        <a href="#routes">Что такое роуты? Как они используются?</a><br />
        <a href="#areas">Что такое Area?</a><br />
        <a href="#getvspost">В чем разница между GET и POST запросами?</a><br />
        <a href="#viewbagvsviewdatavstempdatavssession">В чем разница между ViewBag, ViewData, TempData и Session?</a><br />
        <a href="#mvcEngines">Какие движки представлений есть в MVC?</a><br />
        <a href="#iviewengine">Как реализовать движок представления?</a><br />
        <a href="#dotnetquestion">texthere</a><br />
        <a href="#dotnetquestion">texthere</a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="aboutmvc">
                Что такое MVC? Рассказать про архитектуру ASP.NET MVC (action методы, вьюхи, контроллеры, общий цикл
                жизни запроса).
            </div>
            <div>
                <b>Методы действий (action methods)</b> представляют такие методы контроллера, которые обрабатывают запросы по
                определенному URL. Методы действий всегда имеют модификатор public.<br/> 
				В ASP.NET MVC framework <b>контроллеры</b> – это .NET классы, содержащие логику, необходимую для обработки 
				запроса. Роль контроллера заключается в инкапсуляции логики приложения. Это обозначает, что контроллеры 
				отвечают за обработку входящих запросов, выполняя операции по доменной модели и выбирая представления для 
				отображения пользователю.<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="webconfig">Для чего служит web.config?</div>
            <div>
                <b>Web.config</b> — это XML-документ, определяющий параметры для ASP.NET web-приложения.
            </div>
        </li>
        <li>
            <div class="questiion" id="globalasax">Для чего используется Global.asax?</div>
            <div>
				<b>Файл Global.asax.cs</b> устанавливает некоторые из основных функциональных возможностей MVC при запуске
				приложения. При первом запуске приложения вызывается Application_start() который устанавливает эти 
				возможности.				 
            </div>
        </li>
        <li>
            <div class="questiion" id="routes">Что такое роуты? Как они используются?</div>
            <div>
                <b>Роут</b> - объект который предоставляет свойства и методы для определения маршрута и получения
                сведений о маршруте в ASP.NET.
            </div>
        </li>
        <li>
            <div class="questiion" id="areas">Что такое Area?</div>
            <div>
                <div class="link"> https://www.youtube.com/watch?v=sQdapgqM8-8 </div>
                Для размещения крупных проектов платформа ASP.NET MVC позволяет разделять веб-приложений на более
                мелкие модули, называемые областями. Области позволяют разделить крупное веб-приложение MVC на более
                мелкие функциональные группы. Область является структурой MVC, расположенной внутри приложения.
                Приложение может содержать несколько структур MVC (областей).<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="getvspost">В чем разница между GET и POST запросами?</div>
            <div>
                Негласное правило гласит, что запросы GET следует использовать для получения информации «только для
                чтения» (read-only), в то время как POST запросы должны быть использованы для любой операции, которая
                изменяет состояние приложения. В терминах стандартизации, GET запросы служат для безопасного
                взаимодействия (только для получения информации), а POST запросы для небезопасного взаимодействия
                (принятие решения или изменение чего-то).
            </div>
        </li>
        <li>
            <div class="questiion" id="viewbagvsviewdatavstempdatavssession">
                В чем разница между ViewBag, ViewData, TempData и Session?
            </div>
            <div>
                Все эти объекты предназначены для передачи данных из контроллера в представление.<br />
                <div class="link"> https://www.youtube.com/watch?v=orhZoGslBm8 </div>
                <b>ViewBag</b> является динамическим объектом и создаваемые новые свойства, просто устанавливают их
                значения.<br />
                ViewBag — объект с типом dynamic, кт. позволяет создавать динамически новые свойства и просто
                устанавливать их значения. Является Wrapper’ом объекта ViewData.<br />
                — Жизненный цикл также ограничивается текущий запросом;<br />
                — При редиректе значение также оборачивается в null;<br />
                — Нет необходимости в приведении типов для получения данных<br />
                — Так же, ViewBag имеет преимущество в том, что можно использовать его свойства Strongly typed-методом,
                при этом корректность данных будет проверена еще на этапе компиляции/написания кода.<br />
				<b>ViewData</b> — это словарный объект, производный от TempViewDataDictionary;<br />
                — Используется для передачи данных из контроллера в соответствующее представление;<br />
                — Жизненный цикл ограничен текущим запросом;<br />
                — Если происходит redirect, значение ViewData превращается в null;<br />
                — Также необходимо осуществлять приведение типов и проверять на null, чтобы избежать ошибок;<br />
                <b>TempData</b> представляет словарь, хранящий пары ключ-значение, как и ViewData. TempData позволяет
                сохранять переданное значение в течении всего текущего запроса.<br />
                — Сохранение данных между запросами<br />
                — Время жизни: текущий и следующий запрос<br />
                — Данные после первого прочтения удаляются<br />
                — При использовании Peek("Key") данные не удаляются.<br />
                — После использования данных сделать следующее => @{ TempData.Keep("MyData"); }<br />
                <b>Session</b> <br />
                <div class="link">http://www.cyberguru.ru/microsoft-net/asp-net/aspnet-session-exploration.html?showall=1</div>
                Интернет не сохраняет состояние, а значит, новый экземпляр класса веб-страницы вновь создается
                при каждой отправке страницы на сервер. Как известно, HTTP - протокол без сохранения состояния, он не
                способен хранить клиентскую информацию о странице. Если пользователь вставит какие-то данные и
                перейдет на следующую страницу, то эти данные потеряются, и пользователь не сможет извлечь данные.
                Что нужно? Нужно хранить информацию. Сессия позволяет хранить информацию в памяти сервера. Она
                поддерживает хранение любого типа объекта наряду с пользовательским объектом. Для каждого клиента
                данные сессии хранятся отдельно, то есть данные сессии хранятся согласно клиенту.<br />
                — Сохранение данных между запросами<br />
                — Данные хранятся определенное время. Настраивается в web.config’е.<br />
                <b> &lt;system.web&gt;&lt;sessionState mode="InProc" timeout="1" /&gt;&lt;/system.web&gt; </b>
            </div>
        </li>
        <li>
            <div class="questiion" id="mvcEngines">Какие движки представлений есть в MVC?</div>
            <div>
				<b>Движок Razor</b> появился в третьей версии MVC.<br/>
				<b>Движок ASPX</b> он же движок представлений <b>Web Forms</b>, использует синтаксис тегов <b>Web Forms 
				<% ...%></b>. Он используется для поддержки совместимости в старых приложениях MVC. 
			</div>
        </li>
		<li><b></b>
            <div class="questiion" id="iviewengine">Как реализовать движок представления?</div>
            <div>
				Движки представлений реализуют интерфейс IViewEngine.<br/>
				namespace System.Web.Mvc</br/>
				{</br/>
					public interface IViewEngine</br/>
					{</br/>
						ViewEngineResult FindPartialView(ControllerContext controllerContext,</br/>
						  string partialViewName,</br/>
						  bool useCache);</br/>
						ViewEngineResult FindView(ControllerContext controllerContext,</br/>
						  string viewName,</br/>
						  string masterName,</br/>
						  bool useCache);</br/>
						void ReleaseView(ControllerContext controllerContext, IView view);</br/>
					}</br/>
				}</br/>
			</div>
        </li>
		<li>
            <div class="questiion"></div>
            <div></div>
        </li>
		<li>
            <div class="questiion">Что такое Cookie?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое ModelState?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое Request, Response?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Какие аттрибуты можно использовать в моделях и зачем?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое Claims? Для чего используются?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
    </ul>
	
	<div class="theme" id="solidquestion">Вопросы по SOLID</div>
    <div>
        <a href="#aboutsolid">Расскажите, что означает SOLID</a><br />
        <a href="#solidismean">Расшифруйте SOLID</a><br />
        <a href="#eachprinciplemean">Что означает каждый из принципов?</a><br />
        <a href="#"></a><br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="aboutsolid">Расскажите, что означает SOLID</div>
            <div>
                SOLID - набор правил для проектирования программного кода и построения гибкой и адаптивной программы.
            </div>
        </li>
        <li>
            <div class="questiion" id="solidismean">Расшифруйте SOLID</div>
            <div>
                <b>Single responsibility principle</b><br />
				<b>Open/closed principle</b><br />
				<b>Liskov substitution principle</b><br />
				<b>Interface segregation principle</b><br />
				<b>Dependency inversion principle</b><br />
            </div>
        </li>
        <li>
            <div class="questiion" id="eachprinciplemean">Что означает каждый из принципов?</div>
            <div>
                <b>Single responsibility principle</b> - a class should have only a single responsibility (i.e. only one 
				potential change in the software's specification should be able to affect the specification of the class)<br />
                <b>Open/closed principle</b> - software entities should be open for extension, but closed for modification.
				<br />
                <b>Liskov substitution principle</b> - objects in a program should be replaceable with instances of their 
				subtypes without altering the correctness of that program.<br />
                <b>Interface segregation principle</b> - many client-specific interfaces are better than one general-purpose 
				interface.<br />
                <b>Dependency inversion principle</b> - one should depend upon abstractions, [not] concretions.<br />
				<b>RU</b><br />
                <b>Принцип единственной ответственности</b> - У класса должна быть только одна причина для изменения<br />
				<b>Принцип открытости/закрытости</b> - программные сущности должны быть открыты для расширения, но закрыты 
				для модификации<br />
                <b>Принцип подстановки Барбары Лисков</b> - объекты в программе должны быть заменяемыми на экземпляры их 
				подтипов без изменения правильности выполнения программы<br />
                <b>Принцип разделения интерфейса</b> - много интерфейсов, специально предназначенных для клиентов, лучше, чем 
				один интерфейс общего назначения<br />
                <b>Принцип инверсии зависимостей</b> - Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И 
				те и другие должны зависеть от абстракций. <br />
				Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.<br />
            </div>
        </li>
        <li>
            <div class="questiion" id=""></div>
            <div></div>
        </li>
        <li>
            <div class="questiion" id=""></div>
            <div></div>
        </li>
    </ul>
	
	<div class="footer">
	<a class="footerLink" href="#top">To Top</a><br />
	</div>
</body>
</html>
